{
  name: "immediate3D",
  configurations: [
    {
      name: "DEFAULT",
      variants: [
        "USE_POINTS",
        "USE_STANDARD",
        "USE_INSTANCED"
      ]
    }
  ],
  uniforms: [
    { name: "u_view",       type: "f32x4x4" },
    { name: "u_projection", type: "f32x4x4" }
  ],
  shaders: [
    {
      type: "vertex",
      inputs: [
        { name: "a_position",    type: "f32x3" },
        { name: "a_normal",      type: "f32x3" },
        { name: "a_vcolor",      type: "f32x4",   when: "!USE_INSTANCED" },
        { name: "a_icolor",      type: "f32x4",   when: "USE_INSTANCED" },
        { name: "a_transform",   type: "f32x4x4", when: "USE_INSTANCED" }
      ],
      outputs: [
        { name: "vs_color",      type: "f32x4" },
        { name: "vs_normal",     type: "f32x3", when: "!USE_POINTS" },
        { name: "vs_view",       type: "f32x3", when: "USE_STANDARD || USE_INSTANCED" }
      ],
      imports: [
        "srgb_to_linear"
      ],
      source: "
        void main() {
        #if defined(USE_INSTANCED)
          f32x4x4 model = a_transform;
          f32x4 color = srgb_to_linear(a_icolor);
        #else
          f32x4x4 model = f32x4x4(1.0);
          f32x4 color = srgb_to_linear(a_vcolor);
        #endif

          // Transform position into model space.
          f32x4 model_position = model * f32x4(a_position, 1.0);

          // Transform model position into eye space.
          f32x4 eye_position = u_view * model_position;

          // Transform eye position into clip space.
          f32x4 clip_position = u_projection * eye_position;


          rx_position = clip_position;
          vs_color = color;

        #if defined(USE_POINTS)
          f32 distance = length(eye_position.xyz);
          f32 attenuation = inversesqrt(0.1 * distance);
          // The immediate3D packs the point size in normal.x
          rx_point_size = a_normal.x * attenuation;
        #else
          // Transform normal into model space.
          vs_normal = (model * f32x4(a_normal, 0.0)).xyz;

          vs_view = (inverse(u_view) * eye_position).xyz;
        #endif
        }
      "
    },{
      type: "fragment",
      inputs: [
        { name: "vs_color",  type: "f32x4" },
        { name: "vs_view",   type: "f32x3", when: "USE_STANDARD || USE_INSTANCED" },
        { name: "vs_normal", type: "f32x3", when: "!USE_POINTS" }
      ],
      outputs: [
        { name: "fs_color", type: "f32x4" }
      ],
      source: "
        void main() {
        #if defined(USE_POINTS)
          fs_color = vs_color;
        #else
          f32x3 normal = normalize(vs_normal);

          const f32x3 La = f32x3(0.2);
          const f32x3 Ld = f32x3(0.5);
          f32x3 L = normalize(f32x3(0.0, 1.0, 0.0));

          f32x3 Ma = vs_color.xyz;
          f32x3 Md = vs_color.xyz;

          f32x3 va = La * Ma;
          f32x3 vd = max(dot(normal, L), 0.0) * Ld * Md;

          fs_color = f32x4(va + vd, vs_color.a);
        #endif
        }
      "
    }
  ]
}
