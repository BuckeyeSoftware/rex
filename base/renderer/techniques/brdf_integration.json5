{
  name: "brdf_integration",
  shaders: [
    {
      type: "vertex",
      outputs: [
        { name: "vs_coordinate", type: "f32x2" }
      ],
      imports: [
        "fullscreen_triangle"
      ],
      source: "
        void main() {
          f32x4 triangle = fullscreen_triangle();
          rx_position = f32x4(triangle.xy, 0.0, 1.0);
          vs_coordinate = triangle.zw;
        }
      "
    },{
      type: "fragment",
      inputs: [
        { name: "vs_coordinate", type: "f32x2" }
      ],
      outputs: [
        { name: "fs_color",      type: "f32x4" }
      ],
      imports: [
        "hammersley",
        "importance_sample_ggx",
        "schlick"
      ],
      source: "
        f32x2 integrate_brdf(f32 roughness, f32 n_dot_v) {
          f32x3 v = f32x3(sqrt(1.0 - n_dot_v * n_dot_v), 0, n_dot_v);

          f32 a = 0.0;
          f32 b = 0.0;

          u32 samples = 1024u;
          for (u32 i = 0u; i < samples; i++) {
            f32x2 Xi = hammersley(i, samples);
            f32x3 h = importance_sample_ggx(Xi, roughness, f32x3(0.0, 0.0, 1.0));
            f32x3 l = reflect(-v, h);

            f32 n_dot_l = clamp(l.z, 0.0, 1.0);
            f32 n_dot_h = clamp(h.z, 0.0, 1.0);
            f32 v_dot_h = clamp(dot(v, h), 0.0, 1.0);

            if (n_dot_l > 0.0) {
              f32 g = schlick(n_dot_l, n_dot_v, roughness);
              f32 v = g * v_dot_h / (n_dot_h * n_dot_v);
              f32 f = pow(1.0 - v_dot_h, 5.0);

              a += (1.0 - f) * v;
              b += f * v;
            }
          }

          return f32x2(a, b) / as_f32(samples);
        }

        void main() {
          f32x2 scale_bias = integrate_brdf(vs_coordinate.x, vs_coordinate.y);
          fs_color = f32x4(scale_bias, 0.0, 1.0);
        }
      "
    }
  ]
}
