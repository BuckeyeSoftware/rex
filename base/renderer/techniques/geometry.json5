{
  name: "geometry",
  permutes: [
    "HAS_SKELETON",
    "HAS_DIFFUSE",
    "HAS_NORMAL",
    "HAS_METALNESS",
    "HAS_ROUGHNESS",
    "HAS_ALPHATEST"
  ],
  uniforms: [
    { name: "u_transform", type: "mat4x4f" },
    { name: "u_model",     type: "mat4x4f" },
    { name: "u_bones",     type: "bonesf",    when: "HAS_SKELETON" },
    { name: "u_diffuse",   type: "sampler2D", value: 0, when: "HAS_DIFFUSE" },
    { name: "u_normal",    type: "sampler2D", value: 1, when: "HAS_NORMAL" },
    { name: "u_metal",     type: "sampler2D", value: 2, when: "HAS_METALNESS" },
    { name: "u_roughness", type: "sampler2D", value: 3, when: "HAS_ROUGHNESS" }
  ],
  shaders: [
    {
      type: "vertex",
      inputs: [
        { name: "a_position",      type: "vec3f" },
        { name: "a_normal",        type: "vec3f" },
        { name: "a_tangent",       type: "vec4f" },
        { name: "a_coordinate",    type: "vec2f" },
        { name: "a_blend_weights", type: "vec4b", when: "HAS_SKELETON" },
        { name: "a_blend_indices", type: "vec4b", when: "HAS_SKELETON" }
      ],
      outputs: [
        { name: "vs_normal",       type: "vec3f" },
        { name: "vs_tangent",      type: "vec4f" },
        { name: "vs_coordinate",   type: "vec2f" },
        { name: "vs_tbn",          type: "mat3x3f", when: "HAS_NORMAL" }
      ],
      source: "
        void main() {
        #if defined(HAS_SKELETON)
          mat3x4f transform  = u_bones[int(a_blend_indices.x)] * a_blend_weights.x / 255.0;
                  transform += u_bones[int(a_blend_indices.y)] * a_blend_weights.y / 255.0;
                  transform += u_bones[int(a_blend_indices.z)] * a_blend_weights.z / 255.0;
                  transform += u_bones[int(a_blend_indices.w)] * a_blend_weights.w / 255.0;

          vec4f position = vec4(vec4(a_position, 1.0) * transform, 1.0);
          mat3x3f adjust_transform = mat3(cross(transform[1].xyz, transform[2].xyz),
                                          cross(transform[2].xyz, transform[0].xyz),
                                          cross(transform[0].xyz, transform[1].xyz));
        #else
          vec4f position = vec4(a_position, 1.0);
        #endif
          vs_normal     = a_normal;
          vs_tangent    = a_tangent;
          vs_coordinate = a_coordinate;

        #if defined(HAS_NORMAL)
          mat4x4f xform = inverse(transpose(u_model));
          vec3f t = normalize(vec3(xform * vec4(a_tangent.xyz, 0.0)));
          vec3f n = normalize(vec3(xform * vec4(a_normal, 0.0)));
          vec3f b = normalize(cross(n, t) * a_tangent.w);

          vs_tbn = mat3x3f(t, b, n);
        #endif

          rx_position   = u_transform * position;
        }
      "
    },{
      type: "fragment",
      inputs: [
        { name: "vs_normal",       type: "vec3f" },
        { name: "vs_tangent",      type: "vec4f" },
        { name: "vs_coordinate",   type: "vec2f" },
        { name: "vs_tbn",          type: "mat3x3f", when: "HAS_NORMAL" }
      ],
      outputs: [
        { name: "fs_albedo",       type: "vec4f" },
        { name: "fs_normal",       type: "vec4f" },
        { name: "fs_emissive",     type: "vec4f" }
      ],
      source: "
        void main() {
        #if defined(HAS_NORMAL)
          // Fetch normal from normal map texture and transform to range [-1, 1]
          vec3f normal_map = normalize(rx_texture2D(u_normal, vs_coordinate).rgb * 2.0 - 1.0);

          // Transform normal map with TBN matrix to get final normal.
          vec3f normal = normalize(vs_tbn * normal_map);
        #else
          vec3f normal = normalize(vs_normal);
        #endif

          // calculate metalness value
          float metalness = 0;
        #if defined(HAS_METALNESS)
          metalness = rx_texture2D(u_metal, vs_coordinate).r;
        #endif

          // calculate roughness value
          float roughness = 0;
        #if defined(HAS_ROUGHNESS)
          roughness = rx_texture2D(u_roughness, vs_coordinate).r;
        #endif

          // calculate diffuse color
          vec4f diffuse = vec4f(0.0);
        #if defined(HAS_DIFFUSE)
          diffuse = rx_texture2D(u_diffuse, vs_coordinate);
        #endif

        #if defined(HAS_ALPHATEST)
          if (diffuse.a <= 0.5) {
            discard;
          }
        #endif

#if 1
          const vec3f La = vec3f(0.5);
          const vec3f Ld = vec3f(0.5);
          vec3f L = normalize(vec3f(0.0, 1.0, 0.0));

          vec3f Ma = diffuse.xyz;
          vec3f Md = diffuse.xyz;

          vec3f va = La * Ma;
          vec3f vd = max(dot(normal, L), 0.0) * Ld * Md;
#endif 

          fs_albedo = vec4f(va + vd    ,        roughness); // roughness stored in alpha
          fs_normal = vec4f(normal * 0.5 + 0.5, metalness); // metalness stored in alpha
        }
      "
    }
  ]
}