{
  name: "geometry",
  permutes: [
    "HAS_SKELETON",
    "HAS_DIFFUSE",
    "HAS_NORMAL",
    "HAS_METALNESS",
    "HAS_ROUGHNESS",
    "HAS_ALPHATEST",
    "HAS_AMBIENT",
    "HAS_EMISSION"
  ],
  uniforms: [
    { name: "u_model",      type: "mat4x4f" },
    { name: "u_view",       type: "mat4x4f" },
    { name: "u_projection", type: "mat4x4f" },
    { name: "u_camera",     type: "vec3f"   },
    { name: "u_mat_xform",  type: "mat3x3f" },
    { name: "u_bones",      type: "bonesf",    when: "HAS_SKELETON" },
    { name: "u_irradiance", type: "samplerCM", value: 0 },
    { name: "u_prefilter",  type: "samplerCM", value: 1 },
    { name: "u_scale_bias", type: "sampler2D", value: 2 },
    { name: "u_diffuse",    type: "sampler2D", value: 3, when: "HAS_DIFFUSE" },
    { name: "u_normal",     type: "sampler2D", value: 4, when: "HAS_NORMAL" },
    { name: "u_metal",      type: "sampler2D", value: 5, when: "HAS_METALNESS" },
    { name: "u_roughness",  type: "sampler2D", value: 6, when: "HAS_ROUGHNESS" },
    { name: "u_ambient",    type: "sampler2D", value: 7, when: "HAS_AMBIENT" },
    { name: "u_emission",   type: "sampler2D", value: 8, when: "HAS_EMISSION" }
  ],
  shaders: [
    {
      type: "vertex",
      inputs: [
        { name: "a_position",      type: "vec3f" },
        { name: "a_normal",        type: "vec3f" },
        { name: "a_tangent",       type: "vec4f" },
        { name: "a_coordinate",    type: "vec2f" },
        { name: "a_blend_weights", type: "vec4b", when: "HAS_SKELETON" },
        { name: "a_blend_indices", type: "vec4b", when: "HAS_SKELETON" }
      ],
      outputs: [
        { name: "vs_normal",       type: "vec3f" },
        { name: "vs_tangent",      type: "vec4f" },
        { name: "vs_coordinate",   type: "vec2f" },
        { name: "vs_position",     type: "vec3f" }
      ],
      source: "
        void main() {
        #if defined(HAS_SKELETON)
          // Calculate transform from bone influences and weights.
          mat3x4f transform  = u_bones[int(a_blend_indices.x)] * a_blend_weights.x / 255.0;
                  transform += u_bones[int(a_blend_indices.y)] * a_blend_weights.y / 255.0;
                  transform += u_bones[int(a_blend_indices.z)] * a_blend_weights.z / 255.0;
                  transform += u_bones[int(a_blend_indices.w)] * a_blend_weights.w / 255.0;

          // Transform position by skeletal transform.
          vec4f position = vec4f(vec4f(a_position, 1.0) * transform, 1.0);
        #else
          vec4f position = vec4f(a_position, 1.0);
        #endif

          // Transform position into clip space.
          vec4f clip_position = u_projection * u_view * u_model * position;

          vs_normal     = a_normal;
          vs_tangent    = a_tangent;
          vs_coordinate = a_coordinate;
          vs_position   = a_position;

          rx_position   = clip_position;
        }
      "
    },{
      type: "fragment",
      inputs: [
        { name: "vs_normal",       type: "vec3f" },
        { name: "vs_tangent",      type: "vec4f" },
        { name: "vs_coordinate",   type: "vec2f" },
        { name: "vs_position",     type: "vec3f" }
      ],
      outputs: [
        { name: "fs_albedo",       type: "vec4f" },
        { name: "fs_normal",       type: "vec4f" },
        { name: "fs_emission",     type: "vec4f" }
      ],
      imports: [
        "normal_encode"
      ],
      source: "
        vec3f approximate_specular_ibl(vec3f specular_color, float roughness, vec3f n, vec3f v) {
          float n_dot_v = clamp(dot(n, v), 0.0, 1.0);
          vec3f r = reflect(-v, n);
          vec3f prefiltered_color = rx_textureCMLod(u_prefilter, r, roughness * 5).rgb;
          vec2f brdf = rx_texture2D(u_scale_bias, vec2f(roughness, n_dot_v)).rg;

          return prefiltered_color * (specular_color * brdf.x + brdf.y);
        }

        void main() {
          // Transform position into model space.
          vec3f position = (u_model * vec4(vs_position, 1.0)).xyz;

        #if defined(HAS_NORMAL)
          // Fetch tangent space normal sample from normal map texture.
          vec3f normal_map_sample = rx_texture2D(u_normal, vs_coordinate).rgb;

          // Transform normal map sample to range [-1, 1].
          vec3f normal_map = normal_map_sample * 2.0 - 1.0;

          // Construct bitangent from tangent and normal and apply the bitangent
          // sign which is stored in vs_tangent.w.
          vec3f bitangent = cross(vs_normal, vs_tangent.xyz) * vs_tangent.w;

          // Construct TBN matrix from tangent, bitangent and normal.
          mat3x3f tbn = mat3x3f(vs_tangent.xyz, bitangent, vs_normal);

          // Transform tangent space normal map with TBN matrix and normalize.
          vec3f normal = normalize(tbn * normal_map);
        #else
          vec3f normal = normalize(vs_normal);
        #endif
          // Transform normal into model space.
          normal = normalize(u_model * vec4f(normal, 0.0)).xyz;

          // Calculate metalness facor from material if present.
          float metalness = 0.0;
        #if defined(HAS_METALNESS)
          metalness = rx_texture2D(u_metal, vs_coordinate).r;
        #endif

          // Calculate roughness factor from material if present.
          float roughness = 1.0;
        #if defined(HAS_ROUGHNESS)
          roughness = rx_texture2D(u_roughness, vs_coordinate).r;
        #endif

          // Calculate diffuse factor from material if present.
          vec4f diffuse = vec4f(1.0);
        #if defined(HAS_DIFFUSE)
          diffuse = rx_texture2D(u_diffuse, vs_coordinate);
        #endif

          // Calculate ambient factor from material if present.
          float ambient = 0.0;
        #if defined(HAS_AMBIENT)
          ambient = rx_texture2D(u_ambient, vs_coordinate).r;
        #endif

          // Calculate emission from material if present.
          vec3f emission = vec3f(0.0);
        #if defined(HAS_EMISSION)
          emission = rx_texture2D(u_emission, vs_coordinate).rgb;
        #endif

          // Alpha testing.
        #if defined(HAS_ALPHATEST)
          if (diffuse.a <= 0.5) {
            discard;
          }
        #endif

          // GBuffer layout:
          //
          // R            G          B           A
          // ---------------------------------------------
          // albedo.r,   albedo.g,   albedo.b,   ao
          // normal.r,   normal.g,   roughness,  metalness
          // emission.r, emission.g, emission.b, 0.0
          fs_albedo   = vec4f(diffuse.rgb,           ambient);
          fs_normal   = vec4f(normal_encode(normal), roughness, metalness);
          fs_emission = vec4f(emission,              0.0);
        }
      "
    }
  ]
}
