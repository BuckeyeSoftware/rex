{
  name: "geometry",
  permutes: [
    "HAS_SKELETON",
    "HAS_ALBEDO",
    "HAS_NORMAL",
    "HAS_METALNESS",
    "HAS_ROUGHNESS",
    "HAS_ALPHATEST",
    "HAS_AMBIENT",
    "HAS_EMISSIVE"
  ],
  uniforms: [
    { name: "u_model",           type: "f32x4x4" },
    { name: "u_view",            type: "f32x4x4" },
    { name: "u_projection",      type: "f32x4x4" },
    { name: "u_transform",       type: "f32x3x3", value: [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    { name: "u_bones",           type: "lb_bones", when: "HAS_SKELETON" },
    { name: "u_roughness_value", type: "f32", value: 1.0},
    { name: "u_metalness_value", type: "f32", value: 1.0},
    { name: "u_occlusion_value", type: "f32", value: 1.0},
    { name: "u_albedo_color",    type: "f32x3", value: [1.0, 1.0, 1.0] },
    { name: "u_emissive_color",  type: "f32x3", value: [1.0, 1.0, 1.0] },
    { name: "u_albedo",          type: "sampler2D", value: 0, when: "HAS_ALBEDO" },
    { name: "u_normal",          type: "sampler2D", value: 1, when: "HAS_NORMAL" },
    { name: "u_metalness",       type: "sampler2D", value: 2, when: "HAS_METALNESS" },
    { name: "u_roughness",       type: "sampler2D", value: 3, when: "HAS_ROUGHNESS" },
    { name: "u_ambient",         type: "sampler2D", value: 4, when: "HAS_AMBIENT" },
    { name: "u_emissive",        type: "sampler2D", value: 5, when: "HAS_EMISSIVE" },
    { name: "u_dqbones",         type: "dq_bones", when: "HAS_SKELETON" }
  ],
  shaders: [
    {
      type: "vertex",
      inputs: [
        { name: "a_position",      type: "f32x3" },
        { name: "a_normal",        type: "f32x3" },
        { name: "a_tangent",       type: "f32x4" },
        { name: "a_coordinate",    type: "f32x2" },
        { name: "a_blend_weights", type: "f32x4", when: "HAS_SKELETON" },
        { name: "a_blend_indices", type: "s32x4", when: "HAS_SKELETON" }
      ],
      outputs: [
        { name: "vs_normal",       type: "f32x3" },
        { name: "vs_tangent",      type: "f32x4" },
        { name: "vs_coordinate",   type: "f32x2" }
      ],
      imports: [
        "dual_quaternion_skinning",
        "linear_blend_skinning"
      ],
      source: "
        void main() {
        #if defined(HAS_SKELETON)
          // Dual quaternion skinning.
          // f32x2x4 blend    = dqs(u_dqbones, a_blend_weights, a_blend_indices);
          // f32x3   position = dq_transform_point(blend, a_position);
          // f32x3   normal   = dq_transform_normal(blend, a_normal);

          // Linear blend skinning.
          f32x3x4 blend    = lbs(u_bones, a_blend_weights, a_blend_indices);
          f32x3   position = lbs_transform_point(blend, a_position);
          f32x3   normal   = lbs_transform_normal(blend, a_normal);
        #else
          f32x3 position = a_position;
          f32x3 normal   = a_normal;
        #endif

          // Transform position into clip space.
          f32x4 clip_position = u_projection * u_view * u_model * f32x4(position, 1.0);

          vs_normal     = normal;
          vs_tangent    = a_tangent;
          vs_coordinate = (u_transform * f32x3(a_coordinate, 1.0)).xy;

          rx_position   = clip_position;
        }
      "
    },{
      type: "fragment",
      inputs: [
        { name: "vs_normal",       type: "f32x3" },
        { name: "vs_tangent",      type: "f32x4" },
        { name: "vs_coordinate",   type: "f32x2" }
      ],
      outputs: [
        { name: "fs_albedo",       type: "f32x4" },
        { name: "fs_normal",       type: "f32x4" },
        { name: "fs_emission",     type: "f32x4" }
      ],
      imports: [
        "normal_encode"
      ],
      source: "
        void main() {
          // Calculate albedo factor from material if present.
          f32x4 albedo = f32x4(u_albedo_color, 1.0);
        #if defined(HAS_ALBEDO)
          albedo *= rx_texture2D(u_albedo, vs_coordinate);
        #endif

          // Alpha testing as early as possible.
        #if defined(HAS_ALPHATEST)
          if (albedo.a <= 0.5) {
            discard;
          }
        #endif

          // Calculate roughness factor from material if present.
          f32 roughness = u_roughness_value;
        #if defined(HAS_ROUGHNESS)
          roughness *= rx_texture2D(u_roughness, vs_coordinate).r;
        #endif

          // Calculate metalness facor from material if present.
          f32 metalness = u_metalness_value;
        #if defined(HAS_METALNESS)
          metalness = (1.0 - metalness) * rx_texture2D(u_metalness, vs_coordinate).r;
        #endif

          // Calculate ambient factor from material if present.
          f32 ambient = u_occlusion_value;
        #if defined(HAS_AMBIENT)
          ambient *= rx_texture2D(u_ambient, vs_coordinate).r;
        #endif

          // Calculate emissiveness from material if present.
          f32x3 emission = f32x3(0.0f);
        #if defined(HAS_EMISSIVE)
          emission += rx_texture2D(u_emissive, vs_coordinate).rgb;
        #endif

          // Calculate normal.
        #if defined(HAS_NORMAL)
          // Fetch tangent space normal sample from normal map texture.
          f32x3 normal_map_sample = rx_texture2D(u_normal, vs_coordinate).rgb;

          // Transform normal map sample to range [-1, 1].
          f32x3 normal_map = normal_map_sample * 2.0 - 1.0;

          // Construct bitangent from tangent and normal and apply the bitangent
          // sign which is stored in vs_tangent.w.
          f32x3 bitangent = cross(vs_normal, vs_tangent.xyz) * vs_tangent.w;

          // Construct TBN matrix from tangent, bitangent and normal.
          f32x3x3 tbn = f32x3x3(vs_tangent.xyz, bitangent, vs_normal);

          // Transform tangent space normal map with TBN matrix and normalize.
          f32x3 normal = normalize(tbn * normal_map);
        #else
          f32x3 normal = normalize(vs_normal);
        #endif
          // Transform normal into model space.
          normal = normalize(u_model * f32x4(normal, 0.0)).xyz;

          fs_albedo   = f32x4(albedo.rgb,            ambient);
          fs_normal   = f32x4(normal_encode(normal), roughness, metalness);
          fs_emission = f32x4(emission,              1.0);
        }
      "
    }
  ]
}
