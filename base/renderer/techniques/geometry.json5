{
  name: "geometry",
  configurations: [
    {
      name: "FOR_RIGID",
      permutes: [
        "HAS_ALBEDO",
        "HAS_NORMAL",
        "HAS_METALNESS",
        "HAS_ROUGHNESS",
        "HAS_ALPHATEST",
        "HAS_AMBIENT",
        "HAS_EMISSIVE"
      ]
    },
    {
      name: "FOR_LBS",
      permutes: [
        "HAS_ALBEDO",
        "HAS_NORMAL",
        "HAS_METALNESS",
        "HAS_ROUGHNESS",
        "HAS_ALPHATEST",
        "HAS_AMBIENT",
        "HAS_EMISSIVE"
      ]
    },
    {
      name: "FOR_DQS",
      permutes: [
        "HAS_ALBEDO",
        "HAS_NORMAL",
        "HAS_METALNESS",
        "HAS_ROUGHNESS",
        "HAS_ALPHATEST",
        "HAS_AMBIENT",
        "HAS_EMISSIVE"
      ]
    }
  ],
  uniforms: [
    { name: "u_model",           type: "f32x4x4" },
    { name: "u_view_projection", type: "f32x4x4" },
    { name: "u_last_transform",  type: "f32x4x4" },
    { name: "u_transform",       type: "f32x3x3", value: [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    { name: "u_roughness_value", type: "f32", value: 1.0},
    { name: "u_metalness_value", type: "f32", value: 1.0},
    { name: "u_occlusion_value", type: "f32", value: 1.0},
    { name: "u_albedo_color",    type: "f32x3", value: [1.0, 1.0, 1.0] },
    { name: "u_emissive_color",  type: "f32x3", value: [1.0, 1.0, 1.0] },
    { name: "u_albedo",          type: "sampler2D", value: 0, when: "HAS_ALBEDO" },
    { name: "u_normal",          type: "sampler2D", value: 1, when: "HAS_NORMAL" },
    { name: "u_metalness",       type: "sampler2D", value: 2, when: "HAS_METALNESS" },
    { name: "u_roughness",       type: "sampler2D", value: 3, when: "HAS_ROUGHNESS" },
    { name: "u_ambient",         type: "sampler2D", value: 4, when: "HAS_AMBIENT" },
    { name: "u_emissive",        type: "sampler2D", value: 5, when: "HAS_EMISSIVE" },
    { name: "u_lb_bones",        type: "lb_bones", when: "FOR_LBS" },
    { name: "u_dq_bones",        type: "dq_bones", when: "FOR_DQS" }
  ],
  shaders: [
    {
      type: "vertex",
      inputs: [
        { name: "a_position",       type: "f32x3" },
        { name: "a_occlusion",      type: "f32"   },
        { name: "a_normal",         type: "f32x3" },
        { name: "a_tangent",        type: "f32x4" },
        { name: "a_coordinate",     type: "f32x2" },
        { name: "a_blend_weights",  type: "f32x4", when: "FOR_LBS || FOR_DQS" },
        { name: "a_blend_indices",  type: "s32x4", when: "FOR_LBS || FOR_DQS" }
      ],
      outputs: [
        { name: "vs_normal",        type: "f32x3" },
        { name: "vs_tangent",       type: "f32x4" },
        { name: "vs_coordinate",    type: "f32x2" },
        { name: "vs_this_position", type: "f32x3" },
        { name: "vs_last_position", type: "f32x3" },
        { name: "vs_occlusion",     type: "f32"   }
      ],
      imports: [
        { name: "dual_quaternion_skinning", when: "FOR_DQS" },
        { name: "linear_blend_skinning",    when: "FOR_LBS" }
      ],
      source: "
        void main() {
        #if defined(FOR_DQS)
          // Dual quaternion skinning.
          f32x2x4 blend    = dqs(u_dq_bones, a_blend_weights, as_u32x4(a_blend_indices));
          f32x3   position = dq_transform_point(blend, a_position);
          f32x3   normal   = dq_transform_normal(blend, a_normal);
        #elif defined(FOR_LBS)
          // Linear blend skinning.
          f32x3x4 blend    = lbs(u_lb_bones, a_blend_weights, as_u32x4(a_blend_indices));
          f32x3   position = lbs_transform_point(blend, a_position);
          f32x3   normal   = lbs_transform_normal(blend, a_normal);
        #else
          f32x3 position = a_position;
          f32x3 normal   = a_normal;
        #endif

          f32x4x4 this_transform = u_view_projection * u_model;
          f32x4x4 last_transform = u_last_transform;

          // Transform positions into clip space.
          f32x4 this_position = this_transform * f32x4(position, 1.0);
          f32x4 last_position = last_transform * f32x4(position, 1.0);

          vs_normal        = normal;
          vs_tangent       = a_tangent;
          vs_coordinate    = (u_transform * f32x3(a_coordinate, 1.0)).xy;
          vs_this_position = this_position.xyw;
          vs_last_position = last_position.xyw;
          vs_occlusion     = a_occlusion;

          rx_position      = this_position;
        }
      "
    },{
      type: "fragment",
      inputs: [
        { name: "vs_normal",        type: "f32x3" },
        { name: "vs_tangent",       type: "f32x4" },
        { name: "vs_coordinate",    type: "f32x2" },
        { name: "vs_this_position", type: "f32x3" },
        { name: "vs_last_position", type: "f32x3" },
        { name: "vs_occlusion",     type: "f32"   }
      ],
      outputs: [
        { name: "fs_albedo",        type: "f32x4" },
        { name: "fs_normal",        type: "f32x4" },
        { name: "fs_emission",      type: "f32x4" },
        { name: "fs_velocity",      type: "f32x2" }
      ],
      imports: [
        "normal_encode"
      ],
      source: "
        void main() {
          // Calculate albedo factor from material if present.
          f32x4 albedo = f32x4(u_albedo_color, 1.0);
        #if defined(HAS_ALBEDO)
          albedo *= rx_texture2D(u_albedo, vs_coordinate);
        #endif

          // Alpha testing as early as possible.
        #if defined(HAS_ALPHATEST)
          if (albedo.a <= 0.5) {
            discard;
          }
        #endif

          // Calculate roughness factor from material if present.
          f32 roughness = u_roughness_value;
        #if defined(HAS_ROUGHNESS)
          roughness *= rx_texture2D(u_roughness, vs_coordinate).r;
        #endif

          // Calculate metalness facor from material if present.
          f32 metalness = u_metalness_value;
        #if defined(HAS_METALNESS)
          metalness = (1.0 - metalness) * rx_texture2D(u_metalness, vs_coordinate).r;
        #endif

          // Calculate ambient factor from material if present.
          f32 ambient = vs_occlusion * u_occlusion_value;
        #if defined(HAS_AMBIENT)
          ambient *= rx_texture2D(u_ambient, vs_coordinate).r;
        #endif

          // Calculate emissiveness from material if present.
          f32x3 emission = f32x3(0.0f);
        #if defined(HAS_EMISSIVE)
          emission += rx_texture2D(u_emissive, vs_coordinate).rgb;
        #endif

          // Calculate normal.
        #if defined(HAS_NORMAL)
          // Fetch tangent space normal sample from normal map texture.
          f32x3 normal_map_sample = rx_texture2D(u_normal, vs_coordinate).rgb;

          // Transform normal map sample to range [-1, 1].
          f32x3 normal_map = normal_map_sample * 2.0 - 1.0;

          // Construct bitangent from tangent and normal and apply the bitangent
          // sign which is stored in vs_tangent.w.
          f32x3 bitangent = cross(vs_normal, vs_tangent.xyz) * vs_tangent.w;

          // Construct TBN matrix from tangent, bitangent and normal.
          f32x3x3 tbn = f32x3x3(vs_tangent.xyz, bitangent, vs_normal);

          // Transform tangent space normal map with TBN matrix and normalize.
          f32x3 normal = normalize(tbn * normal_map);
        #else
          f32x3 normal = normalize(vs_normal);
        #endif
          // Transform normal into model space.
          normal = normalize(u_model * f32x4(normal, 0.0)).xyz;

          // Calculate per-pixel velocity.
          f32x2 this_velocity = (vs_this_position.xy / vs_this_position.z) * 0.5 + 0.5;
          f32x2 last_velocity = (vs_last_position.xy / vs_last_position.z) * 0.5 + 0.5;

          fs_albedo   = f32x4(albedo.rgb,            ambient);
          fs_normal   = f32x4(normal_encode(normal), roughness, metalness);
          fs_emission = f32x4(emission,              1.0);
          fs_velocity = this_velocity - last_velocity;
        }
      "
    }
  ]
}
