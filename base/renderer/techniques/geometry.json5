{
  name: "geometry",
  permutes: [
    "HAS_SKELETON",
    "HAS_DIFFUSE",
    "HAS_NORMAL",
    "HAS_METALNESS",
    "HAS_ROUGHNESS"
  ],
  uniforms: [
    { name: "u_transform", type: "mat4x4f" },
    { name: "u_bones",     type: "bonesf",    when: "HAS_SKELETON" },
    { name: "u_diffuse",   type: "sampler2D", when: "HAS_DIFFUSE" },
    { name: "u_normal",    type: "sampler2D", when: "HAS_NORMAL" },
    { name: "u_metal",     type: "sampler2D", when: "HAS_METALNESS" },
    { name: "u_roughness", type: "sampler2D", when: "HAS_ROUGHNESS" }
  ],
  shaders: [
    {
      type: "vertex",
      inputs: [
        { name: "a_position",      type: "vec3f" },
        { name: "a_normal",        type: "vec3f" },
        { name: "a_tangent",       type: "vec4f" },
        { name: "a_coordinate",    type: "vec2f" },
        { name: "a_blend_weights", type: "vec4b", when: "HAS_SKELETON" },
        { name: "a_blend_indices", type: "vec4b", when: "HAS_SKELETON" }
      ],
      outputs: [
        { name: "vs_normal",       type: "vec3f" },
        { name: "vs_tangent",      type: "vec4f" },
        { name: "vs_coordinate",   type: "vec2f" }
      ],
      source: "
        void main() {
        #if defined(HAS_SKELETON)
          mat3x4f transform  = u_bones[int(a_blend_indices.x)] * a_blend_weights.x / 255.0;
                  transform += u_bones[int(a_blend_indices.y)] * a_blend_weights.y / 255.0;
                  transform += u_bones[int(a_blend_indices.z)] * a_blend_weights.z / 255.0;
                  transform += u_bones[int(a_blend_indices.w)] * a_blend_weights.w / 255.0;

          vec4f position = vec4(vec4(a_position, 1.0) * transform, 1.0);
          mat3x3f adjust_transform = mat3(cross(transform[1].xyz, transform[2].xyz),
                                          cross(transform[2].xyz, transform[0].xyz),
                                          cross(transform[0].xyz, transform[1].xyz));
        #else
          vec4f position = vec4(a_position, 1.0);
        #endif
          vs_normal     = a_normal;
          vs_tangent    = a_tangent;
          vs_coordinate = a_coordinate;

          rx_position   = u_transform * position;
        }
      "
    },{
      type: "fragment",
      inputs: [
        { name: "vs_normal",       type: "vec3f" },
        { name: "vs_tangent",      type: "vec4f" },
        { name: "vs_coordinate",   type: "vec2f" }
      ],
      outputs: [
        { name: "fs_albedo",       type: "vec4f" },
        { name: "fs_normal",       type: "vec4f" },
        { name: "fs_emissive",     type: "vec4f" }
      ],
      source: "
        void main() {
          // calculate normal
          vec3f normal = vs_normal;
        #if defined(HAS_NORMAL)
          // tangent space normal map texture
          vec3f bitangent = cross(normal, vs_tangent.xyz) * vs_tangent.w;
          vec3f mapnormal = rx_texture2D(u_normal, vs_coordinate).rgb * 2.0 - 1.0;
          mat3x3f tbn = mat3x3f(vs_tangent, bitangent, normal);
          normal = normalize(tbn * mapnormal);
        #endif
          // consider model matrix
          // TODO(dweiler): normalize((u_model * vec4(normal, 0.0))).xyz;
          // FIXME(dweiler):
          normal = normalize(normal);

          // calculate metalness value
          float metalness = 0;
        #if defined(HAS_METALNESS)
          metalness = rx_texture2D(u_metal, vs_coordinate).r;
        #endif

          // calculate roughness value
          float roughness = 0;
        #if defined(HAS_ROUGHNESS)
          roughness = rx_texture2D(u_roughness, vs_coordinate).r;
        #endif

          // calculate diffuse color
          vec3f diffuse = vec3f(0.0);
        #if defined(HAS_DIFFUSE)
          diffuse = rx_texture2D(u_diffuse, vs_coordinate).rgb;
        #endif

          fs_albedo = vec4f(diffuse, roughness);            // roughness stored in alpha
          fs_normal = vec4f(normal * 0.5 + 0.5, metalness); // metalness stored in alpha
        }
      "
    }
  ]
}